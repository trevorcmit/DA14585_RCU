/**
 ****************************************************************************************
 *
 * \file app_touchpad.c
 *
 * \brief Touchpad module source file
 *
 * Copyright (C) 2017 Dialog Semiconductor.
 * This computer program includes Confidential, Proprietary Information  
 * of Dialog Semiconductor. All Rights Reserved.
 *
 * <bluetooth.support@diasemi.com>
 *
 ****************************************************************************************
 */

/**
 ****************************************************************************************
 * \addtogroup APP_UTILS
 * \{
 * \addtogroup TOUCHPAD
 * \{
 * \addtogroup APP_TOUCHPAD
 * \{
 ****************************************************************************************     
 */ 

#if defined(HAS_TOUCHPAD_TRACKPAD) || defined(HAS_TOUCHPAD_SLIDER)

#include "app_touchpad.h"
#include <app_touchpad_config.h>
#include "port_platform.h"
#include "port_wkup.h"

#define APP_TOUCHPAD_STATE_NORMAL                0x00
#define APP_TOUCHPAD_STATE_TRACKING              0x01

#define _APP_GET_TOUCH_EVT_MASK(x)                (0x0001<<x) 
#define _APP_TOUCH_IS_EVENT_REGISTERED(x)        (_APP_GET_TOUCH_EVT_MASK(x) & _touchevent_setup)



/*
 * LOCAL VARIABLES
*/

// Trackpad notification callbacks
#ifdef HAS_TOUCHPAD_TRACKPAD
// Simple tracking notification callback
static const app_touchpad_cb_t touchpad_track_notification_cb =
        (app_touchpad_cb_t) user_touchpad_track_eventCB;
#endif
// Special event notification callback
static const app_touchpad_cb_t touchpad_special_notification_cb =
        (app_touchpad_cb_t) user_touchpad_special_eventCB;

static uint8_t app_touchpad_first_touch __PORT_RETAINED;

#ifdef HAS_TOUCHPAD_TRACKPAD
static uint8_t _app_touchpad_track_FSM = APP_TOUCHPAD_STATE_NORMAL; // The tracking FSM state variable
static app_touchpad_Coords_t _app_touchpad_current_track_info;
static app_touchpad_Coords_t _app_touchpad_previous_track_info;
static uint8_t app_touchpad_accuInfoIsValid = 0;
#endif

/*
 * LOCAL FUNCTIONS
*/

#ifdef TOUCHPAD_STATIC_EVENT_SETUP
static const uint32_t _touchevent_setup = TOUCHPAD_USER_SETUP;                // The event setup. The registered events that the applications "wants" to be notified about
#else
static uint32_t _touchevent_setup __PORT_RETAINED;                            // The event setup. The registered events that the applications "wants" to be notified about
#endif

static void _app_touchpad_special_engine(app_touchpad_evt_t * touchInfo);
#ifdef HAS_TOUCHPAD_TRACKPAD
static void _app_touchpad_track_engine(app_touchpad_evt_t *touchInfo);
#endif

uint8_t app_touchpad_poll(void)
{
    app_touchpad_evt_t app_touch_evt;

    if(app_touchpad_funcs.app_tpad_poll) {
        if(!app_touchpad_funcs.app_tpad_poll(&app_touch_evt)) {
            return APP_GOTO_SLEEP;
        }
    }
    else {
        ASSERT_ERROR(0);
    }
    
    
    if (app_touchpad_first_touch != 1 && app_touch_evt.touch_action != APP_TOUCHPAD_RESET) {
        app_touchpad_first_touch = 1;
        return APP_GOTO_SLEEP;
    }
#ifdef HAS_TOUCHPAD_TRACKPAD    
    _app_touchpad_track_engine(&app_touch_evt);
#endif
    _app_touchpad_special_engine(&app_touch_evt);
    
    return APP_GOTO_SLEEP;                       
}


#ifdef HAS_TOUCHPAD_TRACKPAD
/**
 ****************************************************************************************
 * \brief Used to handle any tracking events generated from the touchpad
 *
 * \param[in] touchInfo Pointer to the event data generated by the touchpad
 ****************************************************************************************
 */
static void _app_touchpad_track_engine(app_touchpad_evt_t *touchInfo)
{
    uint8_t trackOccured;
    app_touchpad_evt_t app_touch_report;    

    trackOccured = (touchInfo->touch_action == APP_TOUCHPAD_TRACKING);
    
    // Copy the received touch info
    memcpy( &app_touch_report, touchInfo, sizeof(app_touchpad_evt_t) );
    
    // First check the touch pad current state
    switch (_app_touchpad_track_FSM) {
        
        // During Normal State if we receive a tracking event then we change our state to Tracking
        // and update the accumulated coordinates data
        case APP_TOUCHPAD_STATE_NORMAL:
            if (trackOccured) {
                
                app_touchpad_accuInfoIsValid = 0;
                _app_touchpad_track_FSM = APP_TOUCHPAD_STATE_TRACKING;
                
                // Update the reportable touch info
                app_touch_report.touch_action = APP_TOUCHPAD_TRACK_STARTED;
                
                // Update the current new track info
                memcpy(&_app_touchpad_current_track_info, &touchInfo->app_touchpad_coords,
                sizeof(_app_touchpad_current_track_info));
                
                memcpy(&_app_touchpad_previous_track_info, &touchInfo->app_touchpad_coords,
                sizeof(_app_touchpad_previous_track_info));
                
                // Also postpone sleep until the tracking has ended
                port_force_active_mode();

            }
            else {
                        return;
            }
        break;
        
        // During the tracking info and we 
        case APP_TOUCHPAD_STATE_TRACKING:

            app_touchpad_accuInfoIsValid = 1;
            if (!trackOccured) {
                _app_touchpad_track_FSM = APP_TOUCHPAD_STATE_NORMAL;
                app_touch_report.touch_action = APP_TOUCHPAD_TRACK_STOPPED;
                
                // Since tracking has stopped, we can let the MCU to go to sleep
                port_restore_sleep_mode();
            }
                else {
                // Update the current new track info
                memcpy(&_app_touchpad_current_track_info,
                        &touchInfo->app_touchpad_coords,
                        sizeof(_app_touchpad_current_track_info));
            }
            break;
    }
    
    // If the application has registered to get notified about this event
    // and has also registered a callback for it
    if (_APP_GET_TOUCH_EVT_MASK(app_touch_report.touch_action) &
            _touchevent_setup) {
                if (touchpad_track_notification_cb) {
                        touchpad_track_notification_cb(&app_touch_report);
            }
    }
}
#endif

/**
 ****************************************************************************************
 * \brief Used to handle any special events generated from the touchpad
 * \param[in] touchInfo Pointer to the data generated by the touchpad
 ****************************************************************************************
 */
static void _app_touchpad_special_engine(app_touchpad_evt_t * touchInfo)
{
    // Also postpone sleep until the tracking has ended
    if (_APP_GET_TOUCH_EVT_MASK(touchInfo->touch_action) & _touchevent_setup) {
        if (touchpad_special_notification_cb) {
                touchpad_special_notification_cb(touchInfo);
        }
    }
    
}

#ifdef HAS_TOUCHPAD_TRACKPAD
bool app_touchpad_get_last_track_info(app_touchpad_track_data_t * pInfo)
{

        if (app_touchpad_accuInfoIsValid) {
                pInfo->app_touch_delta.deltaX =
                    _app_touchpad_current_track_info.X - _app_touchpad_previous_track_info.X;
                pInfo->app_touch_delta.deltaY =
                    _app_touchpad_current_track_info.Y - _app_touchpad_previous_track_info.Y;
        
        pInfo->app_touch_coords.X = _app_touchpad_current_track_info.X;
        pInfo->app_touch_coords.Y = _app_touchpad_current_track_info.Y;        
        
        // Backup the previous value
        memcpy(&_app_touchpad_previous_track_info, &_app_touchpad_current_track_info,
                sizeof(_app_touchpad_previous_track_info));
        
        // Erase the current value
        memset(&_app_touchpad_current_track_info, 0, sizeof(_app_touchpad_current_track_info));
        
        app_touchpad_accuInfoIsValid = 0;
        return true;
    }    
    
    return false;
    
}
#endif

void app_touchpad_init(void)
{    
    #ifndef TOUCHPAD_STATIC_EVENT_SETUP 
    // Set the events setup mask as given
    _touchevent_setup = (APP_TOUCHPAD_RESET_EVT_MASK | APP_TOUCHPAD_RELEASE_EVT_MASK | 
                             APP_TOUCHPAD_TRACK_STARTED_EVT_MASK | APP_TOUCHPAD_TRACKING_EVT_MASK | 
                             APP_TOUCHPAD_TRACK_STOPPED_EVT_MASK | APP_TOUCHPAD_SF_TAP_EVT_MASK | 
                             APP_TOUCHPAD_SF_TAPHOLD_EVT_MASK | APP_TOUCHPAD_SWIPE_X_POS_EVT_MASK | 
                             APP_TOUCHPAD_SWIPE_X_NEG_EVT_MASK | APP_TOUCHPAD_SWIPE_Y_POS_EVT_MASK | 
                             APP_TOUCHPAD_SWIPE_Y_NEG_EVT_MASK | APP_TOUCHPAD_SCROLL_EVT_MASK | 
                             APP_TOUCHPAD_ZOOM_EVT_MASK | APP_TOUCHPAD_2_FINGER_TAP )    ;
    #endif
    
    // Init the touchpad-related peripherals
    if(app_touchpad_funcs.app_tpad_init) {
        app_touchpad_funcs.app_tpad_init();
    }
    else {
        ASSERT_ERROR(0);
    }
    
#ifdef HAS_TOUCHPAD_TRACKPAD
    // Clear the accumulated track information
    memset(&_app_touchpad_current_track_info, 0, sizeof(_app_touchpad_current_track_info));
    memset(&_app_touchpad_previous_track_info, 0, sizeof(_app_touchpad_previous_track_info));
#endif
}


void app_touchpad_deinit()
{
    
    if(app_touchpad_funcs.app_tpad_deinit) {
        app_touchpad_funcs.app_tpad_deinit();
    }
    else {
        ASSERT_ERROR(0);
    }
    
    #ifndef TOUCHPAD_STATIC_EVENT_SETUP 
    // Clear the event mask setup variable
    _touchevent_setup = 0;
    #endif
#ifdef HAS_TOUCHPAD_TRACKPAD    
    // Set the track FSM state to NORMAL
    _app_touchpad_track_FSM = APP_TOUCHPAD_STATE_NORMAL;
    
    // Clear the accumulated track information
    memset(&_app_touchpad_current_track_info, 0, sizeof(_app_touchpad_current_track_info));
    memset(&_app_touchpad_previous_track_info, 0, sizeof(_app_touchpad_previous_track_info));
#endif    
}

#endif // HAS_TOUCHPAD_TRACKPAD || HAS_TOUCHPAD_SLIDER
/**
 * \}
 * \}
 * \}
 */
